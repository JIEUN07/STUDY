-- 속성(ATTRIBUTE) = 열 (COLUMN)    --> 차수: 속성의 개수
-- 튜플(TUPLE) = 행 (ROW)  --> CARDINALITY: 튜플의 개수
-- 내포 (SCHEMA 스키마) = 전체
-- 외연 (INSTANCE 인스턴스) = 성분 데이터

-- 관계 RELATIONSHIP
-- 슈퍼키: 중복되지 않은 튜플을 가진 속성의 집합 (유일한 값이 튜플에 할당)
-- 후보키: 중복되지 않은 튜플을 가진 속성의 최소집합
-- 기본키: 후보키들 중 하나 대표로 삼는 키
-- 대리키: 일련번호등의 가상의 속성 생성해 기본키로 삼음
-- 대체키: 기본키로 선정되지 않은 후보키
-- 슈퍼키: 튜플 유일하게 식별할수있는값은 모두 가능
-- 외래키: 다른 테이블에 있는 키

-- 데이터베이스 생성, 테이블 할당
CREATE DATABASE LECTURE;
USE LECTURE;
drop table if exists summer;
create table summer(sid integer, class varchar(20), price integer);

insert into summer values(100, 'FORTRAN', 20000);
insert into summer values(150, 'PASCAL', 15000);
insert into summer values(200, 'C', 10000);
insert into summer values(250, 'FORTRAN', 20000);

create table summerprice(class varchar(20) primary key, price integer);
create table summerEnroll(sid integer primary key, class varchar(20));


-- 정규화
CREATE TABLE 
SUMMERENROLL(SID INTEGER, CLASS VARCHAR(20),
FOREIGN KEY(SID) REFERENCES SUMMER(SID) ON UPDATE CASCADE,
FOREIGN KEY(CLASS) REFERENCES SUMMER(CLASS) ON UPDATE CASCADE);

SELECT DISTINCT CLASS, PRICE
FROM SUMMER; -- 중복제거
SELECT * FROM SUMMERPRICE;

INSERT INTO SUMMERENROLL
SELECT SID, CLASS FROM SUMMER
WHERE SID IS NOT NULL;
ALTER TABLE SUMMER ADD  PRIMARY KEY(SID);
ALTER TABLE SUMMER modify column CLASS varchar(20) unique;
ALTER TABLE SUMMERENROLL ADD CONSTRAINT
FOREIGN KEY(SID) REFERENCES SUMMER(SID);
ALTER TABLE SUMMERENROll ADD CONSTRAINT
FOREIGN KEY(CLASS) REFERENCES SUMMERPRICE(CLASS);

SELECT * FROM SUMMER;
UPDATE SUMMER SET SID = 300 
WHERE CLASS = 'JAVA';

USE BOOKSTORE;


USE SAKILA;
SELECT COUNT(*) FROM RENTAL;

-- 데이터테이블 외부에 저장
SELECT * FROM RENTAL
INTO OUTFILE "C:/ProgramData/MySQL/MySQL Server 8.0/Uploads/RENTAL.csv" -- 경로지정은 바꿀수 없음 (셋팅을 바꾸지 않는한)
FIELDS TERMINATED BY ',' -- 구분기호 지정									-- '와 " 안가림, 경로가 프로그램내에 지정되어있어도 경로를 꼭 붇여줘야함 +이름
LINES TERMINATED BY '\N'; -- 라인 바꿈??

-- 외부 데이터 가져오기
-- MYSQL 소스면 호출가능
-- https://www.mysqltutorial.org/mysql-sample-database.aspx (다운로드 링크)
-- 경로는 보기에 숨긴파일 해제한 후 c드라이브 > 프로그램 데이터 > 마이sql > 업데이트파일 경로 긁어오기

CREATE DATABASE MYDATA;
USE MYDATA;
-- 데이터테이블 가져오기 (csv) -- 테이블데이터 임포트위자드
-- https://www.kaggle.com/nicapotato/womens-ecommerce-clothing-reviews
-- https://github.com/billyrohh/dataset/blob/master/dataset3.csv
-- https://github.com/billyrohh/instacart_dataset

CREATE DATABASE INSTACART;
USE INSTACART;
-- https://github.com/billyrohh/instacart_dataset


-- 프로젝트 연습
-- 자동차 매출 데이터 이용
USE CLASSICMODELS;

-- 1) 매출액 조회
-- 일별 매출액 조회
SELECT ORDERDATE , SUM(PRICEEACH * QUANTITYORDERED) PRICE 
FROM ORDERS
INNER JOIN ORDERDETAILS
ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER
GROUP BY 1  -- 각각의 날짜별 매출액
ORDER BY 1 ;

DESC ORDERS;

-- 월별 매출액 조회
SELECT SUBSTR(ORDERDATE, 1, 7) MON, SUM(PRICEEACH * QUANTITYORDERED) PRICE 
FROM ORDERS
INNER JOIN ORDERDETAILS
ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER
GROUP BY 1  -- 각각의 날짜별 매출액
ORDER BY 1 ;

-- 년도별 매출액 조회
SELECT SUBSTR(ORDERDATE, 1, 4) YEAR, SUM(PRICEEACH * QUANTITYORDERED) PRICE 
FROM ORDERS
INNER JOIN ORDERDETAILS
ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER
GROUP BY 1  -- 각각의 날짜별 매출액
ORDER BY 1 ;

-- 2) 구매자수, 구매 건수, 매출액 
-- 일자별
SELECT ORDERDATE,
COUNT(DISTINCT CUSTOMERNUMBER) NUM_PURCHASER, 
COUNT(ORDERS.ORDERNUMBER) NUM_ORDERS,
SUM(PRICEEACH * QUANTITYORDERED) PRICE 
FROM ORDERS
INNER JOIN ORDERDETAILS
ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER
GROUP BY 1
ORDER BY 1;

-- 월별
SELECT SUBSTR(ORDERDATE, 1, 7) MON,
COUNT(DISTINCT CUSTOMERNUMBER) NUM_PURCHASER, 
COUNT(ORDERS.ORDERNUMBER) NUM_ORDERS,
SUM(PRICEEACH * QUANTITYORDERED) PRICE 
FROM ORDERS
INNER JOIN ORDERDETAILS
ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER
GROUP BY 1
ORDER BY 1;

-- 연도별 매출액, 구매수, 구매건수
SELECT 
SUBSTR(ORDERDATE, 1, 4) YEAR,
COUNT(DISTINCT CUSTOMERNUMBER) NUM_PURCHASER,
COUNT(ORDERS.ORDERNUMBER) NUM_ORDERS,
SUM(PRICEEACH * QUANTITYORDERED) PRICE
FROM
ORDERS
INNER JOIN ORDERDETAILS 
ON ORDERS.ORDERNUMBER = ORDERDETAILS.ORDERNUMBER
GROUP BY 1
ORDER BY 1;

-- 3) 그룹별 구매지표
-- 국가별, 도시별 매출액
-- ORDERS, ORDERDETAILS, CUSTOMERS
SELECT C.COUNTRY, C.CITY,
SUM(PRICEEACH * QUANTITYORDERED) PRICE
FROM ORDERS A
INNER JOIN ORDERDETAILS B
ON A.ORDERNUMBER = B.ORDERNUMBER
INNER JOIN CUSTOMERS C
ON A.CUSTOMERNUMBER = C.CUSTOMERNUMBER
GROUP BY 1,2;

-- 4) 북미, 비북미 매출액 비교
SELECT CASE WHEN COUNTRY IN ('USA', 'CANADA') THEN 'NORTH AMERICA'
ELSE 'OTHERS' END COUNTRY_GRP,
SUM(PRICEEACH * QUANTITYORDERED) PRICE
FROM ORDERS A
INNER JOIN ORDERDETAILS B
ON A.ORDERNUMBER = B.ORDERNUMBER
INNER JOIN CUSTOMERS C
ON A.CUSTOMERNUMBER = C.CUSTOMERNUMBER
GROUP BY 1
ORDER BY 2 DESC ; -- DESC 내림차순

-- 상품 리뷰데이터 이용
USE MYDATA;

ALTER TABLE WOMENREVIEWS 
DROP MYUNKNOWNCOLUMN;
COMMIT; -- 임시메모리 날림???

SELECT * FROM WOMENREVIEWS;

-- DIVISION 평점 평균 계산
ALTER TABLE WOMENREVIEWS RENAME      -- `백 따옴표`(1 옆) 객체(속성)문자 표시 
COLUMN `Division Name` TO DIVISION; -- `Division Name`의 이름을 바꿔줘서 대소문자 구분없게 만들어줌
DESC WOMENREVIEWS;
ALTER TABLE WOMENREVIEWS RENAME 
COLUMN `Department Name` TO DEPARTMENT; -- `Department Name`의 이름을 바꿔줘서 대소문자 구분없게 만들어줌

SELECT DIVISION, AVG(RATING) AVG_RATE
FROM WOMENREVIEWS
GROUP BY 1
ORDER BY 2 DESC;

SELECT DEPARTMENT, AVG(RATING) AVG_RATE
FROM WOMENREVIEWS
GROUP BY 1
ORDER BY 2 DESC;


-- 연령별 분석
SELECT DISTINCT CASE WHEN AGE BETWEEN 0 AND 9 THEN '0009'
WHEN AGE BETWEEN 10 AND 19 THEN '1019'
WHEN AGE BETWEEN 20 AND 29 THEN '2029'
WHEN AGE BETWEEN 30 AND 39 THEN '3039'
WHEN AGE BETWEEN 40 AND 49 THEN '4049'
WHEN AGE BETWEEN 50 AND 59 THEN '5059'
WHEN AGE BETWEEN 60 AND 69 THEN '6069'
WHEN AGE BETWEEN 70 AND 79 THEN '7079'
WHEN AGE BETWEEN 80 AND 89 THEN '8089'
WHEN AGE BETWEEN 90 AND 99 THEN '9099' END AGEBAND,
AGE, COUNT(*)
FROM WOMENREVIEWS
GROUP BY AGEBAND;

SELECT FLOOR(AGE/10)*10 AGEBAND2 FROM WOMENREVIEWS; -- 다른 방법

-- TREND 3점이하의 리뷰 연령분포
SELECT FLOOR(AGE/10)*10 AGEBAND,COUNT(*) CNT
FROM WOMENREVIEWS
WHERE DEPARTMENT = 'TREND' AND RATING <3
GROUP BY 1
ORDER BY 2 DESC;

-- TREND 전체 연령분포
SELECT FLOOR(AGE/10)*10 AGEBAND,COUNT(*) CNT
FROM WOMENREVIEWS
WHERE DEPARTMENT = 'TREND'
GROUP BY 1
ORDER BY 2 DESC;

-- 50대의 TREND 평가
SELECT *
FROM WOMENREVIEWS
WHERE DEPARTMENT = 'TREND' AND RATING < 3
AND AGE BETWEEN 50 AND 59 LIMIT 10;











