USE BOOKSTORE;
-- 내장함수 (SELECT)
SELECT 100+100;
SELECT ABS(178)
FROM DUAL;

-- 반올림 함수
SELECT ROUND(4.893,1);

SELECT CUSTID, ROUND(SUM(SALEPRICE)/COUNT(*)) FROM ORDERS
GROUP BY CUSTID;

-- 도서제목에 야구가 포함된 도서를 농구로 변경한 도서목록
SELECT BOOKID, REPLACE(BOOKNAME, '야구', '농구') BOOKNAME,  PUBLISHER, PRICE
FROM BOOK;

-- 글자의 수 세어주는 함수
-- 굿스포츠에서 출판한 도서 제목과 제목의 글자수
SELECT BOOKNAME 제목, CHAR_LENGTH(BOOKNAME) 문자수, LENGTH(BOOKNAME) 바이트수
FROM BOOK
WHERE PUBLISHER = '굿스포츠';

-- 고객중에 같은 성을 가진 고객 별 명수
SELECT SUBSTR(NAME,1,1) 성, COUNT(NAME) 인원
FROM CUSTOMER
GROUP BY 성;

-- 날짜 함수는 대소문자 구분 있울 수 있음
-- 주문일로부터 10일후에 주문확정할때, 각 주문의 확정일자
SELECT ORDERID 주문번호, ORDERDATE 주문일, ADDDATE(ORDERDATE, INTERVAL 10 DAY) 확정날짜 
FROM ORDERS;

-- 2014년 7월 7일에 주문받은 도선의 주문번호, 주문일, 고객번호, 도서번호 (주문일을 날짜형으로 변환)
SELECT ORDERID 주문번호, STR_TO_DATE(ORDERDATE,'%Y-%m-%d') 주문일, CUSTID 고객번호, BOOKID 도서번호
FROM ORDERS
WHERE ORDERDATE = DATE_FORMAT('20140707','%Y%m%d');
-- WHERE로 검색할때 '20140707'은 문자이므로 날짜로 변경해서 검색해야함


-- DBMS서버에 설정된 현재시간, 요인 확인
SELECT SYSDATE(), DATE_FORMAT(SYSDATE(),'%Y%m%d %M %h:%s') SYSDATE_1;

-- NULL 관련 함수
SELECT NAME, PHONE FROM CUSTOMER
WHERE PHONE IS NULL; -- NULL 값 찾을땐 IS NULL 함수사용함 !=,<> 등의 연산자로는 찾을수 없음 
-- 이름, 전화번호가 포함된 고객목록 (전화번호 없는 고객은 '연락처없음' 표시)
SELECT NAME 이름, IFNULL(PHONE,'연락처없음') 전화번호
FROM CUSTOMER;

CREATE TABLE MYBOOK(BOOKID INTEGER, PRICE INTEGER);
DESC MYBOOK;
INSERT INTO MYBOOK VALUE(1,10000);
INSERT INTO MYBOOK VALUE(2,20000);
INSERT INTO MYBOOK VALUE(3,NULL);
SELECT * FROM MYBOOK;
SELECT * FROM MYBOOK WHERE PRICE IS NULL; -- 가능
SELECT * FROM MYBOOK WHERE PRICE = ''; -- 불가능
SELECT BOOKID, IFNULL(PRICE,0) PRICE FROM MYBOOK;

-- MYSQL에서의 변수정의
-- 변수 이름앞에 @ 붙이고, 정의할때는 ':=' 사용함
SET @NUM := 0; -- ':=' 정의한다
SELECT @NUM;
SELECT (@NUM := @NUM+10) 순번, CUSTID, NAME, PHONE
FROM CUSTOMER;

-- SELECT 부속질의 (스칼라 부속질의)
-- 고객별 판매액, (출력은 고객이름과 고객별판매액)
SELECT NAME FROM CUSTOMER WHERE CUSTID = 1;
SELECT (SELECT NAME FROM CUSTOMER WHERE CUSTID = 1) NAME, SUM(SALEPRICE) TOTAL
FROM ORDERS
GROUP BY ORDERS.CUSTID; -- 비효율적 (N번 반복해야함)

SELECT (SELECT NAME FROM CUSTOMER WHERE CUSTID = ORDERS.CUSTID) NAME, SUM(SALEPRICE) TOTAL
FROM ORDERS
GROUP BY ORDERS.CUSTID; -- 효율

DESC ORDERS;

ALTER TABLE ORDERS ADD BNAME VARCHAR(40);
UPDATE ORDERS
SET BNAME = 
(SELECT BOOKNAME FROM BOOK
WHERE BOOK.BOOKID= ORDERS.BOOKID);

SET SQL_SAFE_UPDATES = 1;

-- 고객번호가 2이하인 고객의 판매액 (고객이름, 판매액)
SELECT CUSTID, NAME FROM CUSTOMER
WHERE CUSTID <= 2; -- 하나의 테이블로 간주

SELECT CS.NAME, SUM(O.SALEPRICE) 
FROM 
(SELECT CUSTID, NAME 
FROM CUSTOMER CS
WHERE CUSTID <= 2) CS
INNER JOIN ORDERS O
ON O.CUSTID = CS.CUSTID
GROUP BY CS.NAME;

-- 3번 고객이 주문한 도서의 최고금액보다
-- 더 비싼 도서를 구입한 주문의 주문번화와 금액
-- 모두만족 ALL 
-- 하나라도 만족 ANY, SOME
SELECT *
FROM ORDERS
WHERE 
SALEPRICE > MAX(SELECT SALEPRICE FROM ORDERS
WHERE CUSTID = '3'); -- 스칼라 값이 아닌 리스트라 대치 불가능

SELECT *
FROM ORDERS
WHERE 
SALEPRICE > ALL(SELECT SALEPRICE FROM ORDERS
WHERE CUSTID = '3'); -- 목록안의 모든 조건을 만족하는지 비교

-- EXISTS 데이터의 존재여부 확인
-- 두테이블이 상관성이 있는지 확인
-- 대한민국에 거주하는 고객에게 판매한 도서의 총판매액
SELECT *
FROM CUSTOMER CS
WHERE ADDRESS LIKE '%대한민국%';

SELECT SUM(SALEPRICE)  TOTAL
FROM ORDERS O
WHERE EXISTS (SELECT *
FROM CUSTOMER CS
WHERE ADDRESS LIKE '%대한민국%' AND O.CUSTID = CS.CUSTID); --  상관성 있을때

SELECT SUM(SALEPRICE)  TOTAL
FROM ORDERS O
WHERE EXISTS (SELECT *
FROM CUSTOMER CS
WHERE ADDRESS LIKE '%대한민국%'); -- 상관성 추가 안했을때 조건이 안걸림

USE SAKILA;

SELECT F.FILM_ID, F.TITLE, COUNT(*) NUM
FROM FILM F
INNER JOIN INVENTORY I
ON F.FILM_ID = I.FILM_ID
GROUP BY F.FILM_ID, F.TITLE;  -- FILM과 INVENTORY의 교집합이어야함

SELECT F.FILM_ID, F.TITLE, COUNT(*) NUM
FROM FILM F
INNER JOIN INVENTORY I
ON F.FILM_ID = I.FILM_ID
GROUP BY F.FILM_ID;

SELECT F.FILM_ID, F.TITLE, COUNT(*) NUM
FROM FILM F
LEFT OUTER JOIN INVENTORY I 
ON F.FILM_ID = I.FILM_ID
GROUP BY F.FILM_ID, F.TITLE; 
-- LEFT OUTER JOIN 함수는 왼쪽열 기준으로 대치항목 정렬시킴
-- 테이블 쓰는 순서대로 왼쪽에 옴
-- 기준을 왼쪽에 둬야함 그래야 기준열 기준으로 NULL값이 대치

USE BOOKSTORE;
SELECT * FROM CUSTOMER;
INSERT INTO CUSTOMER VALUES(6, '조용필', '울산시 대림동','000-1234-1234');
INSERT INTO CUSTOMER VALUES(7, '박미선', '대구시 명동','123-1234-1234');

SELECT *
FROM CUSTOMER CS
INNER JOIN ORDERS O
ON CS.CUSTID = O.CUSTID
GROUP BY CS.CUSTID; -- NULL값은 안나옴 (주문이 없는 경우)

SELECT CS.CUSTID, CS.NAME, COUNT(O.ORDERID) 구매량
FROM CUSTOMER CS
LEFT OUTER JOIN ORDERS O
ON CS.CUSTID = O.CUSTID
GROUP BY CS.CUSTID; -- 주문이 없어도 인식 목록에 고정되어있음

-- 교차조인
SELECT * FROM CATEGORY C
CROSS JOIN LANGUAGE L;

SELECT * FROM CATEGORY; -- 6
SELECT * FROM LANGUAGE; -- 16
SELECT 6*16; -- 96

-- 교차조인으로 날짜 계산
-- SELECT ONES.NUM, TENS.NUM, HUNDREDS.NUM
SELECT ONES.NUM+TENS.NUM+HUNDREDS.NUM
FROM
(SELECT 0 NUM UNION ALL
SELECT 1 NUM UNION ALL
SELECT 2 NUM UNION ALL
SELECT 3 NUM UNION ALL
SELECT 4 NUM UNION ALL
SELECT 5 NUM UNION ALL
SELECT 6 NUM UNION ALL
SELECT 7 NUM UNION ALL
SELECT 8 NUM UNION ALL
SELECT 9 NUM) ONES
CROSS JOIN
(SELECT 0 NUM UNION ALL
SELECT 10 NUM UNION ALL
SELECT 20 NUM UNION ALL
SELECT 30 NUM UNION ALL
SELECT 40 NUM UNION ALL
SELECT 50 NUM UNION ALL
SELECT 60 NUM UNION ALL
SELECT 70 NUM UNION ALL
SELECT 80 NUM UNION ALL
SELECT 90 NUM) TENS
CROSS JOIN 
(SELECT 0 NUM UNION ALL
SELECT 100 NUM UNION ALL
SELECT 200 NUM UNION ALL
SELECT 300 NUM) HUNDREDS
ORDER BY 1; -- 첫째열 기준으로 정렬하겠다.

SELECT DATE_ADD('2020-01-01', INTERVAL(40) DAY); -- INTERVAL 옆에 타입지정

SELECT (DATE_ADD('2020-01-01', INTERVAL(ONES.NUM+TENS.NUM+HUNDREDS.NUM) DAY)) DT
FROM
(SELECT 0 NUM UNION ALL
SELECT 1 NUM UNION ALL
SELECT 2 NUM UNION ALL
SELECT 3 NUM UNION ALL
SELECT 4 NUM UNION ALL
SELECT 5 NUM UNION ALL
SELECT 6 NUM UNION ALL
SELECT 7 NUM UNION ALL
SELECT 8 NUM UNION ALL
SELECT 9 NUM) ONES
CROSS JOIN
(SELECT 0 NUM UNION ALL
SELECT 10 NUM UNION ALL
SELECT 20 NUM UNION ALL
SELECT 30 NUM UNION ALL
SELECT 40 NUM UNION ALL
SELECT 50 NUM UNION ALL
SELECT 60 NUM UNION ALL
SELECT 70 NUM UNION ALL
SELECT 80 NUM UNION ALL
SELECT 90 NUM) TENS
CROSS JOIN 
(SELECT 0 NUM UNION ALL
SELECT 100 NUM UNION ALL
SELECT 200 NUM UNION ALL
SELECT 300 NUM) HUNDREDS
WHERE DATE_ADD('2020-01-01', INTERVAL(ONES.NUM+TENS.NUM+HUNDREDS.NUM) DAY) < '2021-01-01'
-- 21년 1월1일 전까지 조회
ORDER BY 1;


-- 특정 기간동안의 렌탈 기록
SELECT DAYS.DT, COUNT(R.RENTAL_ID) NUM_RENTALS
FROM RENTAL R
RIGHT OUTER JOIN 
(SELECT (DATE_ADD('2005-01-01', INTERVAL(ONES.NUM+TENS.NUM+HUNDREDS.NUM) DAY)) DT
FROM
(SELECT 0 NUM UNION ALL
SELECT 1 NUM UNION ALL
SELECT 2 NUM UNION ALL
SELECT 3 NUM UNION ALL
SELECT 4 NUM UNION ALL
SELECT 5 NUM UNION ALL
SELECT 6 NUM UNION ALL
SELECT 7 NUM UNION ALL
SELECT 8 NUM UNION ALL
SELECT 9 NUM) ONES
CROSS JOIN
(SELECT 0 NUM UNION ALL
SELECT 10 NUM UNION ALL
SELECT 20 NUM UNION ALL
SELECT 30 NUM UNION ALL
SELECT 40 NUM UNION ALL
SELECT 50 NUM UNION ALL
SELECT 60 NUM UNION ALL
SELECT 70 NUM UNION ALL
SELECT 80 NUM UNION ALL
SELECT 90 NUM) TENS
CROSS JOIN 
(SELECT 0 NUM UNION ALL
SELECT 100 NUM UNION ALL
SELECT 200 NUM UNION ALL
SELECT 300 NUM) HUNDREDS
WHERE DATE_ADD('2005-01-01', 
INTERVAL(ONES.NUM+TENS.NUM+HUNDREDS.NUM) DAY) < '2006-01-01') DAYS
ON DAYS.DT = DATE(R.RENTAL_DATE)
GROUP BY DAYS.DT
ORDER BY 1;

-- CASE 조건식 (SELECT 문장 안에)
USE SAKILA;
DESC CUSTOMER;

-- 활성화 고객만 대여횟수 반환
SELECT C.FIRST_NAME, C.LAST_NAME,
CASE
WHEN C.ACTIVE = 0 THEN 0
ELSE 
(SELECT COUNT(*) FROM RENTAL R
WHERE R.CUSTOMER_ID = C.CUSTOMER_ID)
END NUM_RENTALS -- END뒤에는 이름지정
FROM CUSTOMER C;

-- 2005년 5, 6, 7월 영화 대여 횟수
SELECT MONTHNAME(RENTAL_DATE) RENTAL_MONTH,
COUNT(*) NUM_RENTALS
FROM RENTAL R
WHERE RENTAL_DATE BETWEEN '2005-05-01' AND '2005-08-01'
GROUP BY MONTHNAME(RENTAL_DATE);

-- CASE식 이용해 행,열 바꿈
SELECT 
SUM(CASE WHEN MONTHNAME(RENTAL_DATE) ='MAY' THEN 1 ELSE 0 END) MAY,
SUM(CASE WHEN MONTHNAME(RENTAL_DATE) ='JUNE' THEN 1 ELSE 0 END) JUN,
SUM(CASE WHEN MONTHNAME(RENTAL_DATE) ='JULY' THEN 1 ELSE 0 END) JULY
FROM RENTAL R
WHERE RENTAL_DATE BETWEEN '2005-05-01'AND '2005-08-01';

-- TOTAL 추가
SELECT 
SUM(CASE WHEN MONTHNAME(RENTAL_DATE) ='MAY' THEN 1 ELSE 0 END) MAY,
SUM(CASE WHEN MONTHNAME(RENTAL_DATE) ='JUNE' THEN 1 ELSE 0 END) JUN,
SUM(CASE WHEN MONTHNAME(RENTAL_DATE) ='JULY' THEN 1 ELSE 0 END) JULY,
SUM(CASE WHEN MONTHNAME(RENTAL_DATE) IN ('MAY','JUNE','JULY') THEN 1 ELSE 0 END) TOTAL
FROM RENTAL R
WHERE RENTAL_DATE BETWEEN '2005-05-01'AND '2005-08-01';

-- VIEW 하나이상의 테이블을 합해 만든 가상의 테이블 
-- 원본데이터와 같이 변함
-- 단, 수정 삭제 어려움
USE BOOKSTORE;
CREATE VIEW VW_BOOK AS
SELECT *
FROM BOOK
WHERE BOOKNAME LIKE '%축구%';
SELECT * FROM VW_BOOK;

DROP VIEW VW_BOOK; -- 뷰 삭제

CREATE VIEW VW_CUSTOMER AS
SELECT *
FROM CUSTOMER
WHERE ADDRESS LIKE '%대한민국%';
SELECT * FROM VW_CUSTOMER;

-- ORDDERS 테이블에 고객이름, 도서이름 바로 확인 가능한 뷰
CREATE VIEW VW_ORDERS (ORDERID, CUSTID, NAME, BOOKID, BOOKNAME, SALEPRICE, ORDERDATE) AS 
SELECT O.ORDERID, O.CUSTID, C.NAME, O.BOOKID, B.BOOKNAME, O.SALEPRICE, O.ORDERDATE
FROM ORDERS O
INNER JOIN CUSTOMER C
ON C.CUSTID = O.CUSTID
INNER JOIN BOOK B
ON O.BOOKID = B.BOOKID;
SELECT * FROM VW_ORDERS;

SELECT ORDERID, BOOKNAME, SALEPRICE 
FROM VW_ORDERS
WHERE NAME = '김연아';


CREATE OR REPLACE VIEW 
VW_ORDERS (ORDERID, CUSTID, NAME, BOOKID, BOOKNAME, SALEPRICE, ORDERDATE)
AS SELECT O.ORDERID, O.CUSTID, C.NAME, O.BOOKID, B.BOOKNAME, O.SALEPRICE, O.ORDERDATE
FROM ORDERS O
INNER JOIN CUSTOMER C
ON C.CUSTID = O.CUSTID
INNER JOIN BOOK B
ON O.BOOKID = B.BOOKID;
SELECT * FROM VW_ORDERS;





