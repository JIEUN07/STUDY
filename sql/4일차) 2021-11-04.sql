-- CREATE PROCEDURE 
-- CREATE VIEW와 비슷하지만 좀더 간결하게 해결가능
-- 예시
USE SQLDB;
DROP PROCEDURE IF EXISTS USERPROC; -- 만약 USERPROC가 존재하면 날려라 
DELIMITER $$ -- 딜리미터를 잠시 ;대신 $$로 바꿔줌
CREATE PROCEDURE USERPROC() -- 스토어드 프로시저 이름 (IN 또는 OUT 파라미터)
BEGIN -- BEGIN과 END 는 괄화역할 열었으면 닫아줘야함
SELECT * FROM USERTB1;
 -- 앞에서 실행버튼이 $$로 변경되어 문장 돌아가지않음 
 -- 이 부분에 SQL 프로그래밍 코딩
END $$ 
DELIMITER ; -- 다시 ;로 바꿔줌 이제 위 코드도 실행됨
-- 터미널은 3개 있는거임 $$, ; , $$

CALL USERPROC() -- 스토어드 프로시저 대입

DELIMITER $$
CREATE PROCEDURE USERPROC()
BEGIN
SELECT * FROM CUSTOMER;
END $$
DELIMITER ;
CALL USERPROC();

-- 김연아가 들어간 행 찾아주는 프로시저
DELIMITER $$
CREATE PROCEDURE USERPROC1() 
BEGIN
SELECT *FROM CUSTOMER
WHERE NAME = '김연아';
END $$
DELIMITER ;
CALL USERPROC1();

-- 고객이름에서 원하는 고객 찾아볼수 있게 해주는 프로시저
DESC CUSTOMER;
DELIMITER $$
CREATE PROCEDURE USERPROC2(IN USERNAME VARCHAR(40)) -- IN은 입력값 할당 (IN 입력매개변수 데이터형식)
BEGIN
SELECT *FROM CUSTOMER
WHERE NAME = USERNAME;
END $$
DELIMITER ;
CALL USERPROC2('조용필'); -- IN에서 검색할 내용 지정

-- 데이터 테이블 확인 (검토)
SELECT * FROM BOOK;
INSERT INTO BOOK(BOOKID, BOOKNAME, PUBLISHER, PRICE)
VALUE('12', '스포츠과학', '한국출판사', 23000);

-- 테이블에 행추가해 저장하는 프로시저
DELIMITER $$
CREATE PROCEDURE INSERTBOOK
(IN MYBOOKID INTEGER,
IN MYBOOKNAME VARCHAR(40),
IN MYPUBLISHER VARCHAR(40),
IN MYPRICE INTEGER)
BEGIN
INSERT INTO BOOK(BOOKID, BOOKNAME, PUBLISHER, PRICE)
VALUE(MYBOOKID, MYBOOKNAME, MYPUBLISHER, MYPRICE);
END $$
DELIMITER ;
CALL INSERTBOOK('13', '스포츠과학', '마당과학서적', 25000);
SELECT * FROM BOOK;

-- 동일도서가 있는지 점검후 삽입하는 프로시저
DELIMITER $$
CREATE PROCEDURE BOOKINSERTorUPDATE
(IN MYBOOKID INTEGER,
IN MYBOOKNAME VARCHAR(40),
IN MYPUBLISHER VARCHAR(40),
IN MYPRICE INTEGER)
BEGIN
DECLARE MYCOUNT INTEGER; -- 저장가능한 새로운열 선언
SELECT COUNT(*) INTO MYCOUNT -- INTO는 COUNT함수를 MYCOUNT에 할당
FROM BOOK 
WHERE BOOKNAME LIKE MYBOOKNAME; -- 입력받는 변수이름
IF MYCOUNT != 0 
THEN SET SQL_SAFE_UPDATES = 0; -- UPDATE, DEKETE문에 필요한 설정문 (항상 수정가능한 상태)
UPDATE BOOK SET PRICE = MYPRICE
WHERE BOOKNAME LIKE MYBOOKNAME;
-- SET SQL_SAFE_UPDATES=1; 업데이트 막을때, 수정금지시킬때 사용 (수정금지)
ELSE
INSERT INTO BOOK(BOOKID, BOOKNAME, PUBLISHER, PRICE)
VALUE(MYBOOKID, MYBOOKNAME, MYPUBLISHER, MYPRICE);
END IF;
END $$
DELIMITER ;
CALL BOOKINSERTorUPDATE('14', '야구의 추억', '한국출판사', 13000);
CALL BOOKINSERTorUPDATE('14', '배구의 추억', '프랑스출판사', 5000);
SELECT * FROM BOOK;

-- COUNT함수 사용전 검토
SELECT COUNT(*) FROM BOOK
WHERE BOOKNAME LIKE '야구의 추억';
-- UPDATE함수 사용전 검토
UPDATE BOOK SET PRICE = 7000
WHERE BOOKNAME LIKE '야구의 추억';
SELECT * FROM BOOK
WHERE BOOKNAME LIKE '야구의 추억';

-- BOOK테이블에 저장된 도서의 평균가격 반환 프로시저
DELIMITER $$
CREATE PROCEDURE AVERAGEPRICE(OUT AVERAGEVAL INTEGER)
BEGIN
SELECT AVG(PRICE) INTO AVERAGEVAL FROM BOOK
WHERE PRICE IS NOT NULL;
END$$
DELIMITER ;

SHOW PROCEDURE STATUS;
CALL AVERAGEPRICE(@MYRESULT); -- 이름지정해서 반환
SELECT @MYRESULT;

SELECT AVG(PRICE) FROM BOOK
WHERE PRICE IS NOT NULL; -- 14487.1429
INSERT INTO BOOK VALUES(100, 'AAA','AAA', NULL);
INSERT INTO BOOK VALUES(200, 'AAA','AAA', NULL);

-- 새로운 테이블 하나 생성(기존에 존재하지 않을경우)
CREATE TABLE IF NOT EXISTS 
TESTTBL(ID INT AUTO_INCREMENT PRIMARY KEY,
TXT CHAR(20));
DESC TESTTBL;
SELECT * FROM TESTTBL;

DELIMITER $$
CREATE PROCEDURE 
TESTTBLINSERT(IN TXTVALUE CHAR(10), OUT OUTVALUE INT)
BEGIN
INSERT INTO TESTTBL VALUE(NULL, TXTVALUE);
SELECT MAX(ID) INTO OUTVALUE FROM TESTTBL;
END$$
DELIMITER ;

-- 삽입함수 사용전 검토
INSERT INTO TESTTBL VALUE(NULL, '연습이오');
SELECT MAX(ID) FROM TESTTBL; 
SHOW PROCEDURE STATUS;

CALL TESTTBLINSERT('TEST TEST', @MYVALUE);
CALL TESTTBLINSERT('지은', @MYVALUE);
SELECT CONCAT('현재입력된 ID : ', @MYVALUE) RESULT; -- CONCAT은 ()안 변수들을 한줄로 붙인다는 뜻

-- 커서 사용 프로시저 (읽을 위치 지정)
-- ORDERS테이블의 판매도서에 대한 이익 계산 프로시저
-- SELECT한 테이블을 통째로 커서에 넣어버림
DELIMITER $$
CREATE PROCEDURE INTEREST()
BEGIN
  DECLARE MYINTEREST INTEGER DEFAULT 0.0; -- 기본값 0.0으로 지정
  DECLARE PRICE INTEGER;
  DECLARE ENDOFROW BOOLEAN DEFAULT FALSE; 
  DECLARE INSERESTCUSOR CURSOR FOR 
  SELECR SALEPRICE FROM ORDERS;
  DECLARE CONTINUE HANDLER
  FOR NOT FOUND SET ENDOFROW = TRUE;

  OPEN InterestCursor;
  cursor_loop: LOOP
    FETCH InterestCursor INTO Price;
    IF endOfRow THEN LEAVE cursor_loop; 
    END IF;
    IF Price >= 30000 THEN 
        SET myInterest = myInterest + Price * 0.1;
    ELSE 
        SET myInterest = myInterest + Price * 0.05;
    END IF;
  END LOOP cursor_loop;
  CLOSE InterestCursor;
  SELECT CONCAT(' 전체 이익 금액 = ', myInterest);
END;
$$
delimiter ;
CALL Interest();

-- 테이블에 열하나 추가후 구매총액 따라 회원등급 설정
USE SQLDB;
DESC USERTBL;
DESC BUYTBL; -- 두개를 같이 돌리면 같이 나옴

ALTER TABLE USERTBL ADD GRADE VARCHAR(5); -- 테이블에 GRADE 열 추가
DROP PROCEDURE IF EXISTS GRADEPROC; 
DELIMITER $$
CREATE PROCEDURE GRADEPROC()
BEGIN
DECLARE ID VARCHAR(10);
DECLARE HAP BIGINT; -- 큰정수
DECLARE USERGRADE CHAR(5);
DECLARE ENDOFROW BOOLEAN DEFAULT FALSE; -- ENDOFROW 끝이면 (TRUE) 종료시키는 함수
DECLARE USERCURSOR CURSOR FOR   -- 밑의 SELECT문을 USERCUSOR에 할당해줌
SELECT U.USERID, SUM(PRICE*AMOUNT) TOTAL -- FECTH와 열개수 맞춰주ㅓ야함
FROM USERTBL U
LEFT OUTER JOIN BUYTBL B -- INNER JOIN은 둘다 있는 레코드만 가져옴, OUTER는 다 가져옴
ON U.USERID = B.USERID
GROUP BY U.USERID, U.NAME;

DECLARE CONTINUE HANDLER  -- 행의 끝이면 ENDOFROW에 TURE 대입
FOR NOT FOUND SET ENDOFROW = TRUE; -- 더이상 찾을게 없으면 끝내라
-- 중간에 셋팅해놔도 알아서 점프해 찾아감 (LOOP 없이도 중간에 써도 가능)

OPEN USERCURSOR; -- USERCURSOR테이블 열어줌
GRADE_LOOP: LOOP -- 루프 이름지정
FETCH USERCURSOR INTO ID, HAP; -- 첫 행 값을 대입
IF ENDOFROW THEN LEAVE GRADE_LOOP; --  ENDOFROW가 TURE 로 바뀌면 끝냄 (위 HANDLE에서 걸림)
END IF;
CASE WHEN (HAP > 1500) THEN SET USERGRADE = '최우수고객';
WHEN (HAP > 1) THEN SET USERGRADE = '우수고객';
ELSE SET USERGRADE = '유령고객';
END CASE; 

UPDATE USERTBL SET GRADE = USERGRADE WHERE USERID = ID; -- 루프돌기전에 업데이트
END LOOP GRADE_LOOP;-- LOOP(반복문)가 있으면 계속 END LOOP로 닫아줘야함 
CLOSE USERCURSOR; -- 항상 오픈햇으면 닫아줘야함

END$$
DELIMITER ;

SELECT * FROM USERTBL;
CALL GRADEPROC();

-- CASE문 사용전 검토
SELECT U.USERID, U.NAME, SUM(PRICE*AMOUNT) TOTAL,
(CASE WHEN (SUM(PRICE*AMOUNT) > 0) THEN '우수고객'
ELSE '유령고객' END) GRADE
FROM USERTBL U
LEFT OUTER JOIN BUYTBL B -- INNER JOIN은 둘다 있는 레코드만 가져옴, OUTER는 다 가져옴
ON U.USERID = B.USERID
GROUP BY U.USERID, U.NAME;

-- TRIGGER (함정처럼 깔아놓을수있음)
-- 데이터의 변경문(INERT, DELETE, UPDATE) 실행될때 자동으로 실행되는 프로시저
-- 따라서 직접수행 못함, 이벤트에 '걸려야' 수행됨 
-- VIEW에는 못씀, 실제 데이터가 없기 때문
-- IN, OUT 매개변수 사용 못함

-- 데이터베이스 불러옴
CREATE DATABASE IF NOT EXISTS testDB; -- 데이터베이스 생성
USE testDB;
CREATE TABLE IF NOT EXISTS TESTTBL (id INT, txt VARCHAR(10));
INSERT INTO testTbl VALUES(1, '레드벨벳');
INSERT INTO testTbl VALUES(2, '잇지');
INSERT INTO testTbl VALUES(3, '블랙핑크');

-- TESTTBL의 ID=4인 열이 삭제되면 트리거 작동
DELIMITER $$
CREATE TRIGGER TESTTRG
AFTER DELETE ON TESTTBL FOR EACH ROW -- TESTTBL에 DELETE 실행 후(AFTER) 각 열에 실행
-- 이벤트 조건에 안걸려서 이벤트가 실행안되면 트리거도 실행안됨
BEGIN
SET @MSG = '가수 그룹이 삭제 됨';
END $$
DELIMITER ;
SHOW TRIGGERS;

-- TRIGGER TEST
SELECT * FROM TESTTBL; 
SET @MSG = ''; -- @MSG에 공간 할당
SELECT @MSG;
INSERT INTO TESTTBL VALUES(4, '마마무');
INSERT INTO TESTTBL VALUES(5, 'ㅇㅇㅇ');
INSERT INTO TESTTBL VALUES(6, 'ㅁㅁㅁ');
SET SQL_SAFE_UPDATES = 0;
DELETE FROM TESTTBL WHERE ID = 5; -- 실행후 다시 SELECT @MSG하면 TRIGGER 실행


-- 사용할 데이터테이블 만들기
USE sqlDB;
DROP TABLE IF EXISTS backup_userTbl; -- 구매테이블은 실습에 필요없으므로 삭제.
CREATE TABLE BACKUP_USERTBL
(-- ID INT AUTO_INCREMENT PRIMARY KEY,
userID  CHAR(8) NOT NULL PRIMARY KEY, 
  name    VARCHAR(10) NOT NULL, 
  birthYear   INT NOT NULL,  
  addr	  CHAR(2) NOT NULL, 
  mobile1	CHAR(3), 
  mobile2   CHAR(8), 
  height    SMALLINT,  
  mDate    DATE,
  modType  CHAR(2), -- 변경된 타입. '수정' 또는 '삭제'
  modDate  DATE, -- 변경된 날짜
  modUser  VARCHAR(256) -- 변경한 사용자
);

-- DELETE 걸리면 실행되는 트리거
DELIMITER $$
CREATE TRIGGER BACKUPUSERTBL_DELETETRGG
AFTER DELETE ON USERTBL FOR EACH ROW 
BEGIN
INSERT INTO BACKUP_USERTBL VALUES(NULL, OLD.USERID, OLD.NAME, OLD.BIRTHYEAR, 
OLD.ADDR, OLD.MOBILE1, OLD.MOBILE2, OLD.HEIGHT, OLD.mDATE,
'삭제', CURDATE(), USER()); -- USER() USERMOD 뽑아오는 함수
END $$
DELIMITER ;
-- UPDATE 걸리면 실행되는 트리거
DELIMITER $$
CREATE TRIGGER BACKUPUSERTBL_UPDATETRGGG
AFTER UPDATE ON USERTBL FOR EACH ROW 
BEGIN
INSERT INTO BACKUP_USERTBL VALUES(OLD.USERID, OLD.NAME, OLD.BIRTHYEAR,
OLD.ADDR, OLD.MOBILE1, OLD.MOBILE2, OLD.HEIGHT, OLD.mDATE,
'수정', CURDATE(), USER());
END $$
DELIMITER ;

SHOW TRIGGERS;

SELECT * FROM USERTBL;
SELECT * FROM BACKUP_USERTBL;

UPDATE USERTBL SET HEIGHT = HEIGHT* 1.1; -- 전체 다 고치는 (FOR EACH ROW) 업데이트

USE MYSQL;
SELECT * FROM MYSQL;
 

-- STORED FUNCTION 스토어드함수  (스토어드 프로시저와 유사)
-- 사용자 정의 함수
-- 사용자가 직접 만들어서 사용
-- SELECT문 안에서 호출 가능

-- 출생연도 입력하면 나이출력되는 함수지정
DROP FUNCTION IF EXISTS GETAGEFUNC;
SET GLOBAL LOG_BIN_TRUST_FUNCTION_CREATORS = 1; -- 로그데이터 설정
DELIMITER $$
CREATE FUNCTION GETAGEFUNC(BYEAR INT) RETURNS INT
BEGIN
DECLARE AGE INT;
SET AGE = YEAR(CURDATE()) - BYEAR;
RETURN AGE;
END $$
DELIMITER ; -- BYEAR 넣으면 AGE로 반출

SELECT GETAGEFUNC(1980);


















