-- 17P 내장함수의 결과
SELECT ABS(-15); -- 15
SELECT CEIL(15.7); -- 16
SELECT COS(3.14159); -- -0.9999999999964793
SELECT FLOOR(15.7); -- 15
SELECT LOG(10.100); -- 2.312535423847214
SELECT MOD(11,4); -- 3
SELECT POWER(3,2); -- 9
SELECT SIGN(-15); -- -1
SELECT TRUNC(15.7);
SELECT CHAR(67 USING UTF8); -- C
SELECT CONCAT('HAPPY', 'BIRTHDAY'); -- HAPPYBIRTHDAY
SELECT LOWER('BIRTHDAY'); -- birthday
SELECT LPAD('PAGE 1', 15, '*'); -- *********PAGE 1


-- 24P
USE BOOKSTORE;
-- 2. 1)
SELECT * FROM BOOK;

-- 2. 2)
SET @RNUM = 0;
SELECT *, @RNUM := @RNUM + 1 AS ROWNUM
FROM BOOK, (SELECT @RNUM := 0) R
WHERE @RNUM < 5;

-- 2. 3)
SET @RNUM = 0;
SELECT *, @RNUM := @RNUM + 1 AS ROWNUM
FROM BOOK , (SELECT @RNUM := 1) R
WHERE @RNUM <= 5;

USE SAKILA;
-- 53P 1. 1) 새로 만든 테이블 데이터 사용해 고객의 총지불액과 고객의이름 반환
--         해당고객의 지불기록이 없는경우 모든고객 포함
CREATE TABLE CUST(CUSTOMER_ID INTEGER, NAME VARCHAR(40));
DESC CUST;
INSERT INTO CUST VALUE(1, 'JOHN SMITH');
INSERT INTO CUST VALUE(2, 'KATHY JONES');
INSERT INTO CUST VALUE(3, 'GREG OLIVER');
SELECT * FROM CUST;

CREATE TABLE PM(PAYMENT_ID INTEGER, CUSTOMER_ID INTEGER, AMOUNT DECIMAL(5,2));
DESC PM;
INSERT INTO PM VALUE(101, 1, 8.99);
INSERT INTO PM VALUE(102, 3, 4.99);
INSERT INTO PM VALUE(103, 1, 7.99);
SELECT * FROM PM;
DROP TABLE PM;

SELECT C.NAME, SUM(PM.AMOUNT) TOTAL
FROM CUST C
LEFT OUTER JOIN PM
ON C.CUSTOMER_ID = PM.CUSTOMER_ID
GROUP BY C.NAME;

-- 1. 2) 오른쪽 외부조인 사용해 재구성
SELECT C.NAME, SUM(PM.AMOUNT) TOTAL
FROM PM
RIGHT OUTER JOIN CUST C
ON C.CUSTOMER_ID = PM.CUSTOMER_ID
GROUP BY C.NAME;

-- 1. 3) {1,2,3,...,99,100} 집합생성 쿼리 작성
--           적어도 두개이상의 FROM절 서브쿼리 교차조인사용
SELECT (NUM+NUM2+NUM3) NUM4
FROM
(SELECT 0 NUM UNION ALL
SELECT 1 NUM UNION ALL
SELECT 2 NUM UNION ALL
SELECT 3 NUM UNION ALL
SELECT 4 NUM UNION ALL
SELECT 5 NUM UNION ALL
SELECT 6 NUM UNION ALL
SELECT 7 NUM UNION ALL
SELECT 8 NUM UNION ALL
SELECT 9 NUM) ONES
CROSS JOIN
(SELECT 0 NUM2 UNION ALL
SELECT 10 NUM2 UNION ALL
SELECT 20 NUM2 UNION ALL
SELECT 30 NUM2 UNION ALL
SELECT 40 NUM2 UNION ALL
SELECT 50 NUM2 UNION ALL
SELECT 60 NUM2 UNION ALL
SELECT 70 NUM2 UNION ALL
SELECT 80 NUM2 UNION ALL
SELECT 90 NUM2) TENS
CROSS JOIN
(SELECT 0 NUM3 UNION ALL
SELECT 100 NUM3) HUNDREDS
WHERE NUM+NUM2+NUM3 BETWEEN 1 AND 100
ORDER BY 1;

-- 62P 1. 1) 최대한 WHEN절을 적게 사용해 단순화
SELECT NAME,
CASE 
WHEN NAME IN ('ENGLISH', 'ITALIAN', 'FRENCH', 'GERMAN') THEN 'LATIN1'
WHEN NAME IN ('JAPANESE', 'MANDARIN') THEN 'UTF8'
ELSE 'UNKNOWN'
END  CHARACTER_SET
FROM LANGUAGE;

-- 1. 2)
SELECT RATING, COUNT(*)
FROM FILM
GROUP BY RATING;

SELECT 
SUM(CASE WHEN RATING = 'G' THEN 1 ELSE 0 END) G,
SUM(CASE WHEN RATING = 'PG' THEN 1 ELSE 0 END) PG,
SUM(CASE WHEN RATING = 'NC-17' THEN 1 ELSE 0 END) NC_17,
SUM(CASE WHEN RATING = 'R' THEN 1 ELSE 0 END) R,
SUM(CASE WHEN RATING = 'PG-13' THEN 1 ELSE 0 END) PG_13
FROM FILM;

-- 71P 1. 1) 판매가격 20000원 이상인 도서 도서번호, 도서이름, 고객이름, 출판사, 판매가격
USE BOOKSTORE;
CREATE VIEW HIGHORDERS AS
SELECT B.BOOKID, B.BOOKNAME, C.NAME, B.PUBLISHER, O.SALEPRICE 
FROM ORDERS O
INNER JOIN BOOK B
ON O.BOOKID = B.BOOKID
INNER JOIN CUSTOMER C
ON C.CUSTID = O.CUSTID
WHERE O.SALEPRICE >= 20000;
SELECT * FROM HIGHORDERS; 

CREATE OR REPLACE VIEW HIGHORDERS(BOOKID, BOOKNAME, NAME, PUBLISHER, SALEPRICE)
AS SELECT B.BOOKID, B.BOOKNAME, C.NAME, B.PUBLISHER, O.SALEPRICE 
FROM ORDERS O
INNER JOIN BOOK B
ON O.BOOKID = B.BOOKID
INNER JOIN CUSTOMER C
ON C.CUSTID = O.CUSTID
WHERE O.SALEPRICE >= 20000;

-- 1. 2) 위 뷰를 이용해 판매된 도서의 이름과 고객의 이름 출력
SELECT BOOKNAME, NAME
FROM HIGHORDERS;

-- 1.3) 뷰의 판매가격 삭제후 2)번 다시 수행
CREATE OR REPLACE VIEW HIGHORDERS(BOOKID, BOOKNAME, NAME, PUBLISHER)
AS SELECT B.BOOKID, B.BOOKNAME, C.NAME, B.PUBLISHER
FROM ORDERS O
INNER JOIN BOOK B
ON O.BOOKID = B.BOOKID
INNER JOIN CUSTOMER C
ON C.CUSTID = O.CUSTID
WHERE O.SALEPRICE >= 20000;

SELECT * FROM HIGHORDERS; 








